/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package asap;

import weka.core.converters.ConverterUtils.DataSource;
import weka.core.Instances;
import java.util.logging.Level;
import java.util.logging.Logger;
import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.classifiers.functions.LinearRegression;
import weka.classifiers.lazy.IBk;
import weka.classifiers.trees.M5P;
import weka.classifiers.meta.Stacking;

import weka.classifiers.meta.Vote;
import weka.classifiers.rules.ZeroR;
import java.io.File;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import weka.core.SerializationHelper;

/**
 *
 * @author exam
 */
public class Process {

        Instances instances;
        Classifier classifiers[];
        double[][] predictions;

        public static void main(String[] args) {
                System.out.println(Arrays.toString(args));
                if (args.length < 3) {
                    return;
                }

                if (!(new File(args[0]).isFile()) || !(new File(args[1]).isDir())) {
                    return;
                }
                Process p = new Process();
                
                p.loadFeaturesFile(args[0]);
                p.loadModels(args[1]);
                p.calculatePredictions();
                p.savePredictions(args[2]);
        }
        
        public void loadFeaturesFile(String featuresFilename) {
                
        }
        public void loadModels(String modelsContainerPath) {
                predictions = null;
                
        }
        
        public void calculatePredictions() {
                String idName = "pair_ID";
                String classAttributeName = "relatedness_groundtruth";
                if (predictions != null) {
                        return;
                }
                for(Classifier cl : classifiers) {
                evaluateModel(listOfFile.getAbsolutePath(), classAttributeName, idName);
                }
        }
        
        public void savePredictions(String outputFilename) {
                String[] columnNames = {"pair_ID"};
                
                if (predictions.length == 0) return;
                if (predictions.length == 1)
                        formatPredictions(columnNames, 1, "relatedness_score",
                            "\t", outputFilename);
                else
                        for (int i; i < predictions.length; i++) {
                                formatPredictions(columnNames, 1, "relatedness_score",
                                        "\t", i + "-" + outputFilename);
                        }        
        }

    /**
     * @param args the command line arguments
     */
    public static void runTests(String[] args) {
        int runs = 10, i;
        /*
         Stacking stack = new Stacking();
         M5P m5P = (M5P) CreateClassifier(new M5P(), "-U");
         stack = (Stacking) buildMultipleClassifiersCombiner(stack, m5P, new IBk(1), new LinearRegression());
         stack.setMetaClassifier(CreateClassifier(new M5P(), "-U"));
         buildAndSaveModel(stack,
         "D:\\fsroot\\Dropbox\\Portfolio\\SemEval2015 - Projecto\\"
         + "train_topics_bothtfidf_all.csv");
         */
//
        try {
            System.setOut(new PrintStream("D:\\fsroot\\Dropbox\\Portfolio\\SemEval2015 - Projecto\\run.out"));
        } catch (FileNotFoundException ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }
//
        System.out.println("\n\n\n\t\t********SINGLE THREAD TEST:*********\n\n");
        for (i = 0; i < runs; i++) {
            PerformanceCounters.startTimer("buildModels ST");
            buildModels("D:\\fsroot\\Dropbox\\Portfolio\\SemEval2015 - Projecto\\");
            PerformanceCounters.stopTimer("buildModels ST");
        }
//
        System.out.println("\n\n\n\t\t********MULTI THREAD TEST:*********\n\n");
        for (i = 0; i < runs; i++) {
            PerformanceCounters.startTimer("buildModels MT");
            buildModelsMT("D:\\fsroot\\Dropbox\\Portfolio\\SemEval2015 - Projecto\\");
            PerformanceCounters.stopTimer("buildModels MT");
        }

//        evaluateModels();
//        evaluateTestData();
        PerformanceCounters.printStats();
    }

    private static void evaluateTestData() {

        PerformanceCounters.startTimer("evaluateTestData");
        String baseDir = "D:\\fsroot\\Dropbox\\Portfolio\\SemEval2015 - Projecto\\";
        String inputFilename = baseDir + "train_topics_bothtfidf_all.csv";
        String idName = "pair_ID";
        String[] columnNames = {"pair_ID"};
        String classAttributeName = "relatedness_groundtruth";

        // Directory path here
        String path = baseDir + "Models\\";

        String files;
        File folder = new File(path);
        File[] listOfFiles = folder.listFiles(
                //JDK < 8:                
                new FileFilter() {

                    @Override
                    public boolean accept(File file) {
                        return (file.getName().contains(".model") && !file.getName().contains(".empty"));
                    }
                });
//JDK >= 8 only:
                /*
         (File dir, String name)
         -> (name.contains(".model") && !name.contains(".empty")));
         */
        for (File listOfFile : listOfFiles) {
            if (listOfFile.isFile()) {
                files = listOfFile.getName();
                System.out.println("Evaluating (test) " + files + ":");

                formatPredictions(inputFilename, columnNames,
                        evaluateModel(listOfFile.getAbsolutePath(), inputFilename, classAttributeName, idName),
                        1,
                        "relatedness_score",
                        "\t",
                        listOfFile.getAbsolutePath() + ".out"
                );
            }
        }

        PerformanceCounters.stopTimer("evaluateTestData");
    }
    
private static void formatPredictions(String[] columnNames,
            int predictionsColumnIndex, String predictionsColumnName,
            String columnSeparator, String outputFilename) {
        PerformanceCounters.startTimer("formatPredictions");
            
        File outputFile = new File(outputFilename);
        PrintWriter writer;

        try {
            writer = new PrintWriter(outputFile, "UTF-8");
        } catch (FileNotFoundException | UnsupportedEncodingException ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }

        StringBuilder sb = new StringBuilder();

        for (int i = -1; i < instances.numInstances(); i++) {
            sb.delete(0, sb.length());
            
            for (int j = 0; j < columnNames.length; j++) {
                if (j > 0) {
                    sb.append(columnSeparator);
                }

                if (j == predictionsColumnIndex) {
                    if (i < 0) {
                        sb.append(predictionsColumnName);
                    } else {
                        sb.append(predictions[i]);
                    }
                    sb.append(columnSeparator);
                }
                if (i < 0) {
                    sb.append(columnNames[j]);
                } else {
                    sb.append(instances.instance(i).value(j));
                }
            }

            if (columnNames.length == predictionsColumnIndex) {
                sb.append(columnSeparator);
                if (i < 0) {
                    sb.append(predictionsColumnName);
                } else {
                    sb.append(predictions[i]);
                }
            }

            writer.println(sb);
        }
        writer.flush();
        writer.close();

        PerformanceCounters.stopTimer("formatPredictions");
        }
    private static void formatPredictions(String inputFilename,
            String[] columnNames, double[] predictions,
            int predictionsColumnIndex, String predictionsColumnName,
            String columnSeparator, String outputFilename) {

        PerformanceCounters.startTimer("formatPredictions");
        Instances data;

        try {

            DataSource source = new DataSource(inputFilename);
            data = source.getDataSet();
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }

        File outputFile = new File(outputFilename);
        PrintWriter writer;

        try {
            writer = new PrintWriter(outputFile, "UTF-8");
        } catch (FileNotFoundException | UnsupportedEncodingException ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }

        StringBuilder sb = new StringBuilder();

        for (int i = -1; i < data.numInstances(); i++) {
            sb.delete(0, sb.length());
            for (int j = 0; j < columnNames.length; j++) {
                if (j > 0) {
                    sb.append(columnSeparator);
                }

                if (j == predictionsColumnIndex) {
                    if (i < 0) {
                        sb.append(predictionsColumnName);
                    } else {
                        sb.append(predictions[i]);
                    }
                    sb.append(columnSeparator);
                }
                if (i < 0) {
                    sb.append(columnNames[j]);
                } else {
                    sb.append(data.instance(i).value(j));
                }
            }

            if (columnNames.length == predictionsColumnIndex) {
                sb.append(columnSeparator);
                if (i < 0) {
                    sb.append(predictionsColumnName);
                } else {
                    sb.append(predictions[i]);
                }
            }

            writer.println(sb);
        }
        writer.flush();
        writer.close();

        PerformanceCounters.stopTimer("formatPredictions");
    }

    private static double[] evaluateModel(String modelFilename, String dataFilename, String classAttributeName, String idAttributeName) {
        PerformanceCounters.startTimer("evaluateModel");
        double[] predictions = null;
        try {
                Classifier model = (Classifier) obj;
                // evaluate classifier and print some statistics
                Evaluation eval = new Evaluation(data);

                predictions = eval.evaluateModel(model, data);
                System.out.println("stats for model:" + modelFilename);
                System.out.println(eval.toSummaryString());
            } catch (Exception ex) {
                Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
            }
        PerformanceCounters.stopTimer("evaluateModel");
        return predictions
    }
    private static double[] evaluateModel(String modelFilename, String dataFilename, String idAttributeName) {
        PerformanceCounters.startTimer("evaluateModel");
        Instances data = null;
        double[] predictions = null;

        try {
            DataSource source = new DataSource(dataFilename);
            data = source.getDataSet();
            // setting class attribute if the data format does not provide this information
            // For example, the XRFF format saves the class attribute information as well
            if (data.classIndex() == -1) {
                data.setClass(data.attribute(classAttributeName));
            }

            /*Remove remove = new Remove();
             remove.setAttributeIndices("" + (data.attribute(idAttributeName).index()+1));
             remove.setInputFormat(data);
             data = Filter.useFilter(data, remove);*/
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }
        Object obj = null;
        try {
            obj = SerializationHelper.read(modelFilename);
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }
        if (obj instanceof Classifier) {
            try {
                Classifier model = (Classifier) obj;
                // evaluate classifier and print some statistics
                Evaluation eval = new Evaluation(data);

                predictions = eval.evaluateModel(model, data);
                System.out.println("stats for model:" + modelFilename);
                System.out.println(eval.toSummaryString());
            } catch (Exception ex) {
                Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            System.out.println("model filename given doesn't contain a valid built model!");
        }
        PerformanceCounters.stopTimer("evaluateModel");
        return predictions;
    }

    private static void buildModels(String baseDir) {

        String idAtributeName = "1";    //pair_ID
        String classAtributeName = "relatedness_groundtruth";

        String inputFilename = baseDir + "train_topics_bothtfidf_all.csv";

        String output1Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model1";
//        String output2Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model2";
        String output3Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model3";
        String output4Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model4";
//        String output5Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model5.empty";

        try {
            PerformanceCounters.startTimer("config 1 ST");
            System.out.println("----------------------RUN 1----------------------");
            System.out.println(run1(inputFilename, classAtributeName, idAtributeName, output1Filename));
            PerformanceCounters.stopTimer("config 1 ST");
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }

//        try {
//            PerformanceCounters.startTimer("config 2 ST");
//            System.out.println("----------------------RUN 2----------------------");
//            System.out.println(run2(inputFilename, classAtributeName, idAtributeName, output2Filename));
//            PerformanceCounters.stopTimer("config 2 ST");
//        } catch (Exception ex) {
//            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
//        }
        try {
            PerformanceCounters.startTimer("config 3 ST");
            System.out.println("----------------------RUN 3----------------------");
            System.out.println(run3(inputFilename, classAtributeName, idAtributeName, output3Filename));
            PerformanceCounters.stopTimer("config 3 ST");
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }

        try {
            PerformanceCounters.startTimer("config 4 ST");
            System.out.println("----------------------RUN 4----------------------");
            System.out.println(run4(inputFilename, classAtributeName, idAtributeName, output4Filename));
            PerformanceCounters.stopTimer("config 4 ST");
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }

//        try {
//            PerformanceCounters.startTimer("config 5 ST");
//            System.out.println("----------------------RUN 5----------------------");
//            System.out.println(run5(inputFilename, classAtributeName, idAtributeName, output5Filename));
//            PerformanceCounters.stopTimer("config 5 ST");
//        } catch (Exception ex) {
//            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
//        }

//        try {
//            PerformanceCounters.startTimer("config 5 ST");
//            System.out.println("----------------------RUN 5----------------------");
//            System.out.println(run5(inputFilename, classAtributeName, idAtributeName, output5Filename));
//            PerformanceCounters.stopTimer("config 5 ST");
//        } catch (Exception ex) {
//            Logger.getLogger(ProjectTask1.class.getName()).log(Level.SEVERE, null, ex);
//        }
    }

    private static void buildModelsMT(String baseDir) {

        String idAtributeName = "1";    //pair_ID
        String classAtributeName = "relatedness_groundtruth";

        String inputFilename = baseDir + "train_topics_bothtfidf_all.csv";

        String output1Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model1";
//        String output2Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model2";
        String output3Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model3";
        String output4Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model4";
//        String output5Filename = baseDir + "Models\\train_topics_bothtfidf_all.csv.model5.empty";

        try {
            PerformanceCounters.startTimer("config 1 MT");
            System.out.println("----------------------Config 1----------------------");
            System.out.println(run1mt(inputFilename, classAtributeName, idAtributeName, output1Filename));
            PerformanceCounters.stopTimer("config 1 MT");
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.exit(0);

//        try {
//            PerformanceCounters.startTimer("config 2 MT");
//            System.out.println("----------------------Config 2----------------------");
//            System.out.println(run2mt(inputFilename, classAtributeName, idAtributeName, output2Filename));
//            PerformanceCounters.stopTimer("config 2 MT");
//        } catch (Exception ex) {
//            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
//        }
        try {
            PerformanceCounters.startTimer("config 3 MT");
            System.out.println("----------------------Config 3----------------------");
            System.out.println(run3mt(inputFilename, classAtributeName, idAtributeName, output3Filename));
            PerformanceCounters.stopTimer("config 3 MT");
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }

        try {
            PerformanceCounters.startTimer("config 4 MT");
            System.out.println("----------------------Config 4----------------------");
            System.out.println(run4mt(inputFilename, classAtributeName, idAtributeName, output4Filename));
            PerformanceCounters.stopTimer("config 4 MT");
        } catch (Exception ex) {
            Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
        }
        /*
         try {
         long run5Start = System.currentTimeMillis();
         System.out.println("----------------------RUN 5----------------------");
         //System.out.println(run5(inputFilename, classAtributeName, idAtributeName, output5Filename));
         long run5End = System.currentTimeMillis();
         System.out.println("run5 took " + (run5End - run5Start) + " to build");
         } catch (Exception ex) {
         Logger.getLogger(ProjectTask1.class.getName()).log(Level.SEVERE, null, ex);
         }
        /*
         try {
         long run5Start = System.currentTimeMillis();
         System.out.println("----------------------RUN 5----------------------");
         //System.out.println(run5(inputFilename, classAtributeName, idAtributeName, output5Filename));
         long run5End = System.currentTimeMillis();
         System.out.println("run5 took " + (run5End - run5Start) + " to build");
         } catch (Exception ex) {
         Logger.getLogger(Process.class.getName()).log(Level.SEVERE, null, ex);
         }
         */
    }

    private static String run1(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {

        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[3];
        //String[] options = new String[1];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        LinearRegression lr = new LinearRegression();
        M5P metatree = new M5P();         // new instance of tree

        //options[0] = "-U";            // unpruned tree
        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = lr;
        //tree.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidation(inputFilename, className, removeIndices, stack, seed, folds, inputFilename + ".tmp", modelOutputFilename);
    }

    private static String run2(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {

        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[5];
        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        LinearRegression lr = new LinearRegression();
        ZeroR zeroR = new ZeroR();

        //IsotonicRegression isotonicRegression = new IsotonicRegression();
        M5P metatree = new M5P();         // new instance of tree

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = lr;
        classifiers[3] = zeroR;
        //classifiers[4] = isotonicRegression;

        options[0] = "-M";            // unpruned tree
        options[1] = "4";            // unpruned tree
        tree.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidation(inputFilename, className, removeIndices, stack, seed, folds, "", modelOutputFilename);
    }

    private static String run1mt(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {

        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[3];
        //String[] options = new String[1];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        LinearRegression lr = new LinearRegression();
        M5P metatree = new M5P();         // new instance of tree

        //options[0] = "-U";            // unpruned tree
        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = lr;
        //tree.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidationMT(inputFilename, className, removeIndices, stack, seed, folds, inputFilename + ".tmp", modelOutputFilename);
    }

    private static String run2mt(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {

        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[5];
        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        LinearRegression lr = new LinearRegression();
        ZeroR zeroR = new ZeroR();
        //IsotonicRegression isotonicRegression = new IsotonicRegression();

        M5P metatree = new M5P();         // new instance of tree

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = lr;
        classifiers[3] = zeroR;
        //classifiers[4] = isotonicRegression;

        options[0] = "-M";            // unpruned tree
        options[1] = "4";            // unpruned tree
        tree.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidationMT(inputFilename, className, removeIndices, stack, seed, folds, "", modelOutputFilename);
    }

    /**
     * *************************************************************************
     * ***********************************************************************
     * *
     **************************************************************************
     */
    private static String run3(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {

        Vote vote = new Vote();

        Classifier[] classifiers = new Classifier[7];
        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        M5P tree2 = new M5P();         // new instance of tree
        IBk knn2 = new IBk(3);
        M5P tree3 = new M5P();         // new instance of tree
        IBk knn3 = new IBk(5);
        LinearRegression lr = new LinearRegression();

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = tree2;
        classifiers[3] = knn2;
        classifiers[4] = tree3;
        classifiers[5] = knn3;
        classifiers[6] = lr;

        options[0] = "-M";            // ...
        options[1] = "4";            // number of ...
        tree.setOptions(options);     // set the options

        options = new String[3];
        options[0] = "-M";            // ...
        options[1] = "10";            // number of ...
        options[2] = "-R";           //unpruned tree
        tree2.setOptions(options);     // set the options

        options = new String[2];
        options[0] = "-M";            // ...
        options[1] = "20";            // number of ...
        tree3.setOptions(options);     // set the options

        vote.setClassifiers(classifiers);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidation(inputFilename, className, removeIndices, vote, seed, folds, "", modelOutputFilename);
    }

    private static String run3mt(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {

        Vote vote = new Vote();

        Classifier[] classifiers = new Classifier[7];
        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        M5P tree2 = new M5P();         // new instance of tree
        IBk knn2 = new IBk(3);
        M5P tree3 = new M5P();         // new instance of tree
        IBk knn3 = new IBk(5);
        LinearRegression lr = new LinearRegression();

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = tree2;
        classifiers[3] = knn2;
        classifiers[4] = tree3;
        classifiers[5] = knn3;
        classifiers[6] = lr;

        options[0] = "-M";            // ...
        options[1] = "4";            // number of ...
        tree.setOptions(options);     // set the options

        options = new String[3];
        options[0] = "-M";            // ...
        options[1] = "10";            // number of ...
        options[2] = "-R";           //unpruned tree
        tree2.setOptions(options);     // set the options

        options = new String[2];
        options[0] = "-M";            // ...
        options[1] = "20";            // number of ...
        tree3.setOptions(options);     // set the options

        vote.setClassifiers(classifiers);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidationMT(inputFilename, className, removeIndices, vote, seed, folds, "", modelOutputFilename);
    }

    private static String run4(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {
        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[7];

        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        M5P tree2 = new M5P();         // new instance of tree
        IBk knn2 = new IBk(3);
        M5P tree3 = new M5P();         // new instance of tree
        IBk knn3 = new IBk(5);
        LinearRegression lr = new LinearRegression();

        M5P metatree = new M5P();         // new instance of tree

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = tree2;
        classifiers[3] = knn2;
        classifiers[4] = tree3;
        classifiers[5] = knn3;
        classifiers[6] = lr;

        options[0] = "-M";            // unpruned tree
        options[1] = "4";            // unpruned tree
        tree.setOptions(options);     // set the options

        options = new String[3];
        options[0] = "-M";            // ...
        options[1] = "10";            // number of ...
        options[2] = "-R";           //unpruned tree
        tree2.setOptions(options);     // set the options

        options = new String[2];
        options[0] = "-M";            // unpruned tree
        options[1] = "20";            // unpruned tree
        tree3.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidation(inputFilename, className, removeIndices, stack, seed, folds, "", modelOutputFilename);
    }

    private static String run4mt(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {
        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[7];

        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        M5P tree2 = new M5P();         // new instance of tree
        IBk knn2 = new IBk(3);
        M5P tree3 = new M5P();         // new instance of tree
        IBk knn3 = new IBk(5);
        LinearRegression lr = new LinearRegression();

        M5P metatree = new M5P();         // new instance of tree

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = tree2;
        classifiers[3] = knn2;
        classifiers[4] = tree3;
        classifiers[5] = knn3;
        classifiers[6] = lr;

        options[0] = "-M";            // unpruned tree
        options[1] = "4";            // unpruned tree
        tree.setOptions(options);     // set the options

        options = new String[3];
        options[0] = "-M";            // ...
        options[1] = "10";            // number of ...
        options[2] = "-R";           //unpruned tree
        tree2.setOptions(options);     // set the options

        options = new String[2];
        options[0] = "-M";            // unpruned tree
        options[1] = "20";            // unpruned tree
        tree3.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidationMT(inputFilename, className, removeIndices, stack, seed, folds, "", modelOutputFilename);
    }

    private static String run5(String inputFilename, String className,
            String removeIndices, String modelOutputFilename) throws Exception {
        Stacking stack = new Stacking();

        Classifier[] classifiers = new Classifier[7];

        String[] options = new String[2];
        M5P tree = new M5P();         // new instance of tree
        IBk knn = new IBk(1);
        M5P tree2 = new M5P();         // new instance of tree
        IBk knn2 = new IBk(3);
        M5P tree3 = new M5P();         // new instance of tree
        IBk knn3 = new IBk(5);
        LinearRegression lr = new LinearRegression();

        M5P metatree = new M5P();         // new instance of tree

        classifiers[0] = tree;
        classifiers[1] = knn;
        classifiers[2] = tree2;
        classifiers[3] = knn2;
        classifiers[4] = tree3;
        classifiers[5] = knn3;
        classifiers[6] = lr;

        options[0] = "-M";            // unpruned tree
        options[1] = "4";            // unpruned tree
        tree.setOptions(options);     // set the options

        options[0] = "-M";            // unpruned tree
        options[1] = "10";            // unpruned tree
        tree2.setOptions(options);     // set the options

        options[0] = "-M";            // unpruned tree
        options[1] = "20";            // unpruned tree
        tree3.setOptions(options);     // set the options

        stack.setClassifiers(classifiers);
        stack.setMetaClassifier(metatree);

        // other options
        int seed = 1;
        int folds = 10;

        return CrossValidation.performCrossValidation(inputFilename, className, removeIndices, stack, seed, folds, "", modelOutputFilename);
    }

}
